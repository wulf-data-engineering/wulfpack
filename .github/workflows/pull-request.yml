name: Continuous Integration

on:
  pull_request:

jobs:
  seed-template:
    name: Seed Template
    runs-on: ubuntu-latest
    outputs:
      instance-path: ${{ steps.set-path.outputs.path }}
    steps:
      - uses: actions/checkout@v5
      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: pip-cache-cookiecutter
      - name: Install cookiecutter
        run: pip install cookiecutter
      - name: Generate test template instance
        run: |
          # Overwrite defaults to make sure defaults are not part of the seeded template due to copy & paste
          cookiecutter --no-input --output-dir . template/ \
            project_name="Test Instance" \
            project_description="Some sample application." \
            author="GitHub Actions" \
            author_email="git@hub.actions" \
            copyright_pat_env_var="COPYLEFT_PAT" \
            domain_name="foo.bar" \
            hosted_zone_id="undefined" \
            staging_hosted_zone_id="undefined" \
            email_sender_address="no-reply@foo.bar" \
            email_sender_name="Email Sender Name" \
            email_replyto="reply@foo.bar" \
            test_user_email="test@hub.actions" \
            test_user_password="Test456$"
      - name: Verify template contains no default values
        run: |
          python scripts/check_defaults.py --template template/cookiecutter.json --generated test-instance \
            -c project_slug "tool-set-project" \
            -c package_name "tool_set_project" \
            -c email_sender_address "no-reply@wulfpack.wulf.technology" \
            -c email_sender_name "Tool-Set Project" \
            -c email_replyto "no-reply@wulfpack.wulf.technology" \
            --ignore license hosted_zone_id staging_hosted_zone_id
      - name: Upload test template instance
        uses: actions/upload-artifact@v5
        with:
          name: test-instance
          path: test-instance/
          include-hidden-files: true # for .prettierignore etc.
  check-protocols:
    name: Check Protocols
    runs-on: ubuntu-latest
    needs: seed-template
    steps:
      - name: Download test template instance
        uses: actions/download-artifact@v6
        with:
          name: test-instance
          path: ./test-instance
      - uses: bufbuild/buf-setup-action@v1
      - name: Lint protocols
        uses: bufbuild/buf-lint-action@v1
        with:
          input: ./test-instance/protocols
  test-backend:
    name: Test Backend in Template
    runs-on: ubuntu-latest
    needs: seed-template
    defaults:
      run:
        working-directory: ./test-instance/backend
    steps:
      - name: Download test template instance
        uses: actions/download-artifact@v6
        with:
          name: test-instance
          path: ./test-instance
      - name: Install Protoc
        uses: arduino/setup-protoc@v3
      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: pull-request
          workspaces: ./test-instance/backend -> target
          cache-on-failure: true
      - name: Run checks
        id: check
        run: cargo check
      - name: Run clippy
        id: clippy
        run: cargo clippy
      - name: Run unit tests
        id: tests
        run: cargo test --lib --bins
      - name: Aggregate results and fail if any failed
        if: always() # ensure this runs even if earlier steps failed
        run: |
          echo "check outcome:  ${{ steps.check.outcome }}"
          echo "clippy outcome:  ${{ steps.clippy.outcome }}"
          echo "tests outcome:  ${{ steps.tests.outcome }}"

          # If any step outcome is 'failure' then fail the job
          for s in "${{ steps.format.outcome }}" "${{ steps.check.outcome }}" "${{ steps.clippy.outcome }}" "${{ steps.tests.outcome }}"; do
            if [ "$s" = "failure" ]; then
              echo "One or more checks failed."
              exit 1
            fi
          done

          echo "All checks passed."
  test-frontend:
    name: Test Frontend in Template
    runs-on: ubuntu-latest
    needs: seed-template
    defaults:
      run:
        working-directory: ./test-instance/frontend
    steps:
      - name: Download test template instance
        uses: actions/download-artifact@v6
        with:
          name: test-instance
          path: ./test-instance
      - name: Install Protoc
        uses: arduino/setup-protoc@v3
      - name: Setup node
        uses: actions/setup-node@v3
        with:
          node-version: "20"
      - name: Restore cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            test-instance/frontend/node_modules/
          key: node-cache-${{ hashFiles('test-instance/frontend/package.json') }} # template doesn't include a lock file
          restore-keys: node-cache-
      - name: Install dependencies
        run: npm i
      - name: Generate Protocol Buffer files
        run: npm run gen:proto
      - name: Linting
        id: lint
        run: npm run lint
        continue-on-error: true
      - name: Check Svelte with TypeScript
        id: check
        run: npm run check
        continue-on-error: true
      - name: Run unit tests
        id: tests
        run: npm run test:unit
        continue-on-error: true
      - name: Aggregate results and fail if any failed
        if: always() # ensure this runs even if earlier steps failed
        run: |
          echo "lint outcome:   ${{ steps.lint.outcome }}"
          echo "check outcome:  ${{ steps.check.outcome }}"
          echo "tests outcome:  ${{ steps.tests.outcome }}"
          # If any step outcome is 'failure' then fail the job
          for s in "${{ steps.lint.outcome }}" "${{ steps.check.outcome }}" "${{ steps.tests.outcome }}"; do
            if [ "$s" = "failure" ]; then
              echo "One or more checks failed."
              exit 1
            fi
          done

          echo "All checks passed."
  test-e2e:
    name: Test end-to-end in Template
    runs-on: ubuntu-latest
    needs:
      - test-backend
      - test-frontend
    env:
      CI: "true"
    steps:
      - name: Download test template instance
        uses: actions/download-artifact@v6
        with:
          name: test-instance
          path: ./test-instance
      - name: Install Protoc
        uses: arduino/setup-protoc@v3
      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: pull-request
          workspaces: ./test-instance/backend -> target
          cache-on-failure: true
      - name: Install Rust
        run: rustup toolchain install stable
      - name: Install latest cargo-lambda binary
        run: |
          TAG=$(curl -s https://api.github.com/repos/cargo-lambda/cargo-lambda/releases/latest | jq -r .tag_name)
          echo "Latest tag is $TAG"
          ARCH=$(uname -m)
          if [ "$ARCH" = "x86_64" ]; then
            ASSET="cargo-lambda-$TAG.x86_64-unknown-linux-musl.tar.gz"
          elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
            ASSET="cargo-lambda-$TAG.aarch64-unknown-linux-musl.tar.gz"
          else
            echo "Unsupported architecture: $ARCH"
            exit 1
          fi
          echo "Downloading $ASSET"
          curl -fL -o /tmp/cargo-lambda.tar.gz \
            "https://github.com/cargo-lambda/cargo-lambda/releases/download/$TAG/$ASSET"
          sudo tar -xzf /tmp/cargo-lambda.tar.gz -C /usr/local/bin
      - name: Setup node
        uses: actions/setup-node@v3
        with:
          node-version: "20"
      - name: Restore npm cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            test-instance/frontend/node_modules/
          key: node-cache-${{ hashFiles('test-instance/frontend/package-lock.json') }}
          restore-keys: node-cache-
      - name: Restore Playwright browsers cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/ms-playwright
          key: playwright-browsers-${{ hashFiles('test-instance/frontend/package-lock.json') }}
          restore-keys: playwright-browsers-
      - name: Install frontend dependencies and Playwright browsers
        working-directory: test-instance/frontend/
        run: |
          npm i
          npx playwright install-deps
          npx playwright install
          npx playwright --version
      - name: Generate Protocol Buffer files for frontend
        working-directory: test-instance/frontend/
        run: npm run gen:proto
      - name: Build backend for faster start of cargo lambda watch
        working-directory: test-instance/backend/
        run: cargo build
      - name: Run docker compose
        uses: hoverkraft-tech/compose-action@v2.4.0
        with:
          compose-file: "./test-instance/docker-compose.yml"
          services-log-level: info
      - name: Start cargo-lambda watch in background
        working-directory: test-instance/backend/
        run: |
          cargo lambda watch &>/tmp/cargo-lambda-watch.log &
          CARGO_PID=$!
          echo "CARGO_PID=$CARGO_PID" >> $GITHUB_ENV
          echo "Started cargo lambda watch running on pid $CARGO_PID"
      - name: Run Playwright tests
        working-directory: test-instance/frontend/
        run: npm run test:e2e
      - name: Upload Playwright test results
        id: upload-playwright
        if: failure()
        uses: actions/upload-artifact@v5
        with:
          name: playwright-test-results
          path: |
            test-instance/frontend/test-results/
            test-instance/frontend/playwright-report/
            test-instance/frontend/playwright-report/videos/
            test-instance/frontend/playwright-report/screenshots/
            /tmp/cargo-lambda-watch.log
          include-hidden-files: true
      - name: Playwright report
        if: failure()
        run: echo "Playwright report is at ${{ steps.upload-playwright.outputs.artifact-url }}"
      - name: Stop cargo lambda watch
        if: always() # ensure it runs even if previous steps fail
        run: |
          echo "Stopping cargo lambda watch at $CARGO_PID"
          kill $CARGO_PID
